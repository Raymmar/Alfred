 if (!project.recordingUrl) {
          return res.status(400).json({ message: "No recording file associated with this project" });
        }
        const [user] = await db.query.users.findMany({
          where: eq(users.id, req.user!.id),
          limit: 1,
        });
        if (!user.openaiApiKey) {
          return res.status(400).json({ message: "OpenAI API key not set" });
        }
        const openai = new OpenAI({ apiKey: user.openaiApiKey });
        const recordingPath = path.join(RECORDINGS_DIR, project.recordingUrl);
        try {
          await fs.promises.access(recordingPath, fs.constants.R_OK);
        } catch (error) {
          console.error("Recording file access error:", error);
          return res.status(404).json({
            message: "Recording file not found or not accessible",
          });
        }
        // Convert to MP3 for Whisper
        mp3FilePath = path.join(RECORDINGS_DIR, `temp_${Date.now()}.mp3`);
        await new Promise<void>((resolve, reject) => {
          const ffmpeg = spawn("ffmpeg", [
            "-i", recordingPath,
            "-vn",
            "-acodec", "libmp3lame",
            "-ab", "128k",
            "-ar", "44100",
            "-af", "silenceremove=1:0:-50dB",
            "-y",
            mp3FilePath,
          ]);
          ffmpeg.on("error", (error) => {
            console.error("FFmpeg process error:", error);
            reject(new Error(`FFmpeg process failed: ${error.message}`));
          });
          ffmpeg.stdout.on("data", (data) => {
            console.log("FFmpeg stdout:", data.toString());
          });
          ffmpeg.stderr.on("data", (data) => {
            console.log("FFmpeg stderr:", data.toString());
          });
          ffmpeg.on("close", (code) => {
            if (code === 0) resolve();
            else reject(new Error(`FFmpeg process exited with code ${code}`));
          });
        });
        // Get transcription
        console.log("Starting Whisper transcription");
        const transcriptionResponse = await openai.audio.transcriptions.create({
          file: fs.createReadStream(mp3FilePath),
          model: "whisper-1",
        });
        if (!transcriptionResponse.text) {
          throw new Error("No transcription received from OpenAI");
        }
        console.log("Transcription successful, length:", transcriptionResponse.text.length);
        // Format transcript with timestamps
        const formattingResponse = await openai.chat.completions.create({
          model: "gpt-4o",
          messages: [
            {
              role: "system",
              content: `Format the transcript with only these elements:
1. Chapter Headers:
   - Identify key topic changes and sections
   - Format as: "# Topic Title"
   - Place at natural topic transitions
1. Regular Timestamps:
   - Add timestamps [HH:MM:SS.mmm] every 10-30 seconds
   - Place at natural speech breaks
   - Keep timestamps sequential
1.
Format Rules:
- Be sure to send back all of the text
- Always start at the beginning of the recording at 00:00:00
- Each timestamp must be in [HH:MM:SS.mmm] format
- Begin with a chapter header
- Do not add intro or additional formatting
- Add timestamps every 10-30 seconds
- Preserve original text content exactly`,
            },
            {
              role: "user",
              content: transcriptionResponse.text,
            },
          ],
          temperature: 0.3,
          max_tokens: 4000,
        });
        if (!formattingResponse.choices[0]?.message?.content) {
          throw new Error("No formatted transcript generated");
        }
        const formattedTranscript = formattingResponse.choices[0].message.content.trim();
        // Generate title
        const titleResponse = await openai.chat.completions.create({
          model: "gpt-4o",
          messages: [
            {
              role: "system",
              content: "Generate a clear, concise title (max 60 chars) based on the transcript content. Do not insert any additional formatting or punctuation",
            },
            {
              role: "user",
              content: formattedTranscript,
            },
          ],
          temperature: 0.7,
          max_tokens: 60,
        });
        if (!titleResponse.choices[0]?.message?.content) {
          throw new Error("No title generated");
        }
        const title = titleResponse.choices[0].message.content.trim();